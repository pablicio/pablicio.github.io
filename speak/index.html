<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Speak ‚Äî Markdown TTS</title>
<meta name="theme-color" content="#4f46e5"/>
<link rel="stylesheet" href="style.css">
<!-- KaTeX para f√≥rmulas matem√°ticas -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<!-- Highlight.js and Python language -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/nord.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
<!-- Mermaid.js para diagramas -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script src="custom-voices.js"></script>
</head>
<body>

<header class="header">
  <div class="app-title">
    <h1>SpeakDoc</h1>
    <p>Leitor de documenta√ß√£o por voz</p>
  </div>
  <button id="gearBtn" class="icon-btn" title="Configura√ß√µes">‚öôÔ∏è</button>
</header>

<div class="file-card">
  <div class="file-row">
    <label for="fileIn" class="file-btn">üìÑ Abrir documento</label>
    <input id="fileIn" type="file" accept=".md,.markdown,.txt" hidden/>
    <div id="fileName" class="file-name">Nenhum documento carregado</div>
  </div>
</div>

<div id="preview" class="preview"></div>

<footer class="footer">
  <button id="prevBtn" class="small-btn">‚óÄÔ∏é</button>
  <button id="playBtn" class="fab">‚ñ∂</button>
  <button id="nextBtn" class="small-btn">‚ñ∂Ô∏é</button>
</footer>

<script>
  mermaid.initialize({ startOnLoad: false });

  marked.setOptions({
    gfm: true,
    breaks: false,
    mangle: false,
    headerIds: false,
    langPrefix: 'language-'
  });

  // NOTE: Removida a extens√£o de math aqui (KaTeX ser√° aplicada no DOM pelo app.js
  // para evitar duplica√ß√£o e manter tabelas/ordem intactas).

  // Post-render handler ser√° usado pelo app.js, mas expomos uma fun√ß√£o utilit√°ria
  function highlightAllChunks() {
    document.querySelectorAll('pre code').forEach(block => {
      const pre = block.parentElement;
      // Mermaid: trocar apenas se n√£o renderizado antes
      if (block.classList.contains('language-mermaid')) {
        if (pre && !pre.dataset.mermaidRendered) {
          const div = document.createElement('div');
          div.className = 'mermaid';
          div.textContent = block.textContent;
          div.dataset.mermaidRendered = '1';
          pre.replaceWith(div);
          try { mermaid.init(undefined, div); } catch (e) { console.warn('mermaid render:', e); }
        }
        return;
      }

      // C√≥digo normal: usar highlightElement
      try {
        if (window.hljs && typeof hljs.highlightElement === 'function') {
          hljs.highlightElement(block);
        } else if (window.hljs && typeof hljs.highlightBlock === 'function') {
          hljs.highlightBlock(block);
        }
      } catch (e) { console.warn('highlight error', e); }
    });
  }
  window.highlightAllChunks = highlightAllChunks;
</script>
<script src="app.js"></script>
<!-- Leitor aprimorado: intercepta cliques no preview e controla fila de leitura -->
<script>
(function(){
  const preview = document.getElementById('preview');
  const playBtn = document.getElementById('playBtn');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');

  let chunks = [];
  let idx = 0;
  let utter = null;
  let paused = false;
  let reading = false;

  function decodeHtml(html){
    const txt = document.createElement('textarea');
    txt.innerHTML = html;
    return txt.value;
  }

  function sanitizeText(text){
    // Decodifica e normaliza quebras e espa√ßos
    text = decodeHtml(text);
    text = text.replace(/\r\n?/g, '\n');
    // remover excesso de backticks/asteriscos comuns no markdown residual
    text = text.replace(/[`*_]{2,}/g, '');
    // colapsar m√∫ltiplas quebras em ponto para leitura natural
    text = text.replace(/\n{2,}/g, '.\n');
    text = text.replace(/\n/g, '. ');
    text = text.replace(/\s{2,}/g, ' ');
    text = text.trim();
    return text;
  }

  function splitToChunks(text, maxLen = 180){
    // tenta separar por senten√ßas; se senten√ßas grandes, subdivide por v√≠rgulas ou por tamanho
    let parts = text.match(/[^.!?]+[.!?]+(?:\s|$)|.+$/g) || [text];
    const out = [];
    for (let p of parts) {
      p = p.trim();
      if (!p) continue;
      if (p.length <= maxLen) { out.push(p); continue; }
      // quebra por v√≠rgulas se poss√≠vel
      let sub = p.split(/,|\:|;+/).map(s=>s.trim()).filter(Boolean);
      if (sub.length > 1) {
        let acc = '';
        for (let s of sub) {
          if ((acc + ' ' + s).trim().length <= maxLen) {
            acc = (acc + ' ' + s).trim();
          } else {
            if (acc) out.push(acc);
            acc = s;
          }
        }
        if (acc) out.push(acc);
      } else {
        // fallback: cortar em fatias
        for (let i=0;i<p.length;i+=maxLen) out.push(p.slice(i, i+maxLen));
      }
    }
    return out;
  }

  function stopReading(){
    speechSynthesis.cancel();
    if (utter) {
      try { utter.onend = null; } catch(e){}
      utter = null;
    }
    reading = false;
    paused = false;
    playBtn.textContent = '‚ñ∂';
  }

  function startReadingFrom(start=0){
    stopReading();
    if (!chunks || chunks.length === 0) return;
    idx = Math.max(0, Math.min(start, chunks.length - 1));
    reading = true;
    paused = false;
    playBtn.textContent = '‚è∏'; // agora lendo
    speakCurrent();
  }

  function speakCurrent(){
    if (!reading || idx >= chunks.length) {
      stopReading();
      return;
    }
    const text = chunks[idx];
    utter = new SpeechSynthesisUtterance(text);
    // configura√ß√£o b√°sica: voc√™ pode ajustar rate/pitch/voice conforme preferir
    utter.rate = 1.0;
    utter.pitch = 1.0;
    // escolher voice se houver uma que combine com idioma pt-BR
    const voices = speechSynthesis.getVoices();
    if (voices && voices.length) {
      const v = voices.find(v=>/pt[-_]?br|portuguese/i.test(v.lang)) || voices.find(v=>/pt|por/i.test(v.lang)) || voices[0];
      if (v) utter.voice = v;
    }
    utter.onend = () => {
      // s√≥ avan√ßa quando terminar naturalmente
      idx++;
      if (idx < chunks.length) {
        // pequeno delay entre frases para naturalidade
        setTimeout(speakCurrent, 160);
      } else {
        stopReading();
      }
    };
    utter.onerror = (e) => {
      console.warn('synthesis error', e);
      // tenta avan√ßar para n√£o travar
      idx++;
      setTimeout(()=> { if (idx < chunks.length) speakCurrent(); else stopReading(); }, 160);
    };
    try {
      speechSynthesis.speak(utter);
    } catch (e) {
      console.warn('speak failed', e);
      stopReading();
    }
  }

  // Click no preview inicia leitura do bloco clicado (par√°grafo, t√≠tulo, lista, cell, pre)
  preview.addEventListener('click', (ev) => {
    // preferir elementos significativos
    const selector = ev.target.closest('p,li,h1,h2,h3,h4,h5,blockquote,td,th,pre,code') || ev.target;
    if (!selector) return;
    // tratar blocos de c√≥digo: ler com aviso curto (ou pular)
    if